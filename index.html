<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Split-Flap Board — Classic</title>
<style>
  :root {
    --bg: #050505;
    --panel: linear-gradient(180deg,#0a0a0a,#050505);
    --flap-bg: #0b0b0b;
    --flap-edge: #222;
    --text: #fff;
  }

  html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: "Roboto Mono", ui-monospace, SFMono-Regular, Menlo, monospace; -webkit-font-smoothing:antialiased; }

  .wrap { min-height:100vh; display:flex; align-items:center; justify-content:center; padding:24px; box-sizing:border-box; }
  .board {
    background: var(--panel);
    padding: 18px;
    border-radius: 12px;
    box-shadow: 0 18px 50px rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.03);
  }

  .rows { display:flex; flex-direction:column; gap:10px; }
  .row { display:flex; gap:0.14em; align-items:center; justify-content:center; }

  .slot {
    width: calc(1.05ch + 8px);
    height: 3.6rem;
    position:relative;
    perspective:700px;
    display:inline-block;
  }

  .flap {
    width:100%; height:100%; position:relative; box-sizing:border-box;
    border-radius:6px;
    background:var(--flap-bg);
    border:1px solid var(--flap-edge);
    box-shadow: inset 0 -4px 8px rgba(0,0,0,0.6);
    overflow:visible;
  }

  /* static halves (showing current char) */
  .half {
    position:absolute; left:0; right:0; height:50%; display:flex; align-items:center; justify-content:center;
    backface-visibility:hidden; overflow:hidden;
  }
  .half.top { top:0; border-bottom:1px solid rgba(255,255,255,0.03); border-top-left-radius:6px; border-top-right-radius:6px; background: linear-gradient(#111,#0b0b0b); }
  .half.bot { bottom:0; border-top:1px solid rgba(0,0,0,0.6); border-bottom-left-radius:6px; border-bottom-right-radius:6px; background: linear-gradient(#060606,#090909); }

  /* flipping faces (animated) */
  .flip-top, .flip-bot {
    position:absolute; left:0; right:0; height:50%; display:flex; align-items:center; justify-content:center; pointer-events:none;
    transform-origin:bottom center;
  }
  .flip-bot { transform-origin:top center; top:auto; bottom:0; }

  .char { font-size:1.75rem; line-height:1; user-select:none; color:var(--text); }

  /* animation classes applied by JS */
  .anim-top { animation: topFlip 240ms forwards; }
  .anim-bot { animation: botFlip 240ms 160ms forwards; }

  @keyframes topFlip {
    0%   { transform: rotateX(0deg); }
    60%  { transform: rotateX(-110deg); }
    100% { transform: rotateX(-180deg); visibility:hidden; }
  }
  @keyframes botFlip {
    0%   { transform: rotateX(90deg); visibility:hidden; }
    40%  { transform: rotateX(10deg); visibility:visible; }
    100% { transform: rotateX(0deg); visibility:visible; }
  }

  .meta { color:#9aa0a6; font-size:0.82rem; text-align:center; margin-top:10px; }

  @media (max-width:700px) {
    .slot { width: calc(0.95ch + 6px); height:3.0rem; }
    .char { font-size:1.25rem; }
    .board { padding:12px; border-radius:8px; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="board" id="boardRoot" role="region" aria-label="Departure board">
      <div class="rows" id="rowsContainer"></div>
      <div class="meta" id="meta">Booting… (tap page to enable sound)</div>
    </div>
  </div>

<script>
/* ================= CONFIG ================= */
const BOARD_JSON = 'board.json';   // file in repo root
const ROWS = 5;
const COLS = 24;
const POLL_MS = 5000;
const STEP_MS = 60; // step interval per glyph
const GLYPH_ORDER = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-.,:/()'.split('');
const AUDIO_ENABLED_MSG = 'Tap to enable sound';

/* =============== AUDIO ENGINE =============== */
const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioContextCtor ? new AudioContextCtor() : null;

function playTick(volume = 0.25, freq = 1700, dur = 0.03) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.value = freq;
  g.gain.value = volume * 0.8;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
  setTimeout(()=> g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur), 1);
}

function playRattle(intensity = 0.8, duration = 0.12) {
  if (!audioCtx) return;
  // create short noise burst
  const sr = audioCtx.sampleRate;
  const buffer = audioCtx.createBuffer(1, sr * duration, sr);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) {
    const t = i / data.length;
    data[i] = (Math.random() * 2 - 1) * (1 - t) * intensity * (Math.random() > 0.6 ? 1 : 0.6);
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 2000;
  filter.Q.value = 0.7;
  const gain = audioCtx.createGain();
  gain.gain.value = 0.9 * intensity;
  src.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
  src.start();
  src.stop(audioCtx.currentTime + duration);
}

/* allow mobile browsers to resume audio on user gesture */
document.addEventListener('click', () => {
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }
}, { once: true });

/* =============== BUILD DOM =============== */
const rowsContainer = document.getElementById('rowsContainer');
const meta = document.getElementById('meta');
const boardSlots = []; // rows -> slots

function buildBoard() {
  rowsContainer.innerHTML = '';
  boardSlots.length = 0;
  for (let r = 0; r < ROWS; r++) {
    const rowEl = document.createElement('div');
    rowEl.className = 'row';
    const slots = [];
    for (let c = 0; c < COLS; c++) {
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.innerHTML = `
        <div class="flap">
          <div class="half top"><div class="char current-top"> </div></div>
          <div class="half bot"><div class="char current-bot"> </div></div>
          <div class="flip-top"><div class="char next-top"> </div></div>
          <div class="flip-bot"><div class="char next-bot"> </div></div>
        </div>`;
      rowEl.appendChild(slot);

      const f = {
        el: slot,
        topStatic: slot.querySelector('.current-top'),
        botStatic: slot.querySelector('.current-bot'),
        flipTop: slot.querySelector('.flip-top'),
        flipTopChar: slot.querySelector('.flip-top .next-top'),
        flipBot: slot.querySelector('.flip-bot'),
        flipBotChar: slot.querySelector('.flip-bot .next-bot'),
        current: ' '
      };
      slots.push(f);
    }
    boardSlots.push(slots);
    rowsContainer.appendChild(rowEl);
  }
}
buildBoard();

/* =============== GLYPH HELPERS =============== */
function glyphIndex(ch) {
  const s = (ch || ' ').toString().toUpperCase();
  const i = GLYPH_ORDER.indexOf(s);
  return i === -1 ? 0 : i;
}
function nextGlyph(cur, target) {
  const a = glyphIndex(cur);
  const b = glyphIndex(target);
  if (a === b) return cur;
  let i = (a + 1) % GLYPH_ORDER.length;
  return GLYPH_ORDER[i];
}

/* =============== FLIP SCHEDULER =============== */
function scheduleFlip(slot, targetChar, delay = 0) {
  return new Promise(resolve => {
    let cur = slot.current || ' ';
    const tgt = (targetChar || ' ').toString().toUpperCase();
    if (cur === tgt) { resolve(); return; }

    function step() {
      const next = nextGlyph(cur, tgt);
      // prepare faces
      slot.flipTopChar.textContent = cur;
      slot.flipBotChar.textContent = next;

      // reset classes
      slot.flipTop.classList.remove('anim-top');
      slot.flipBot.classList.remove('anim-bot');
      // force reflow
      void slot.flipTop.offsetWidth;
      void slot.flipBot.offsetWidth;
      // animate
      slot.flipTop.classList.add('anim-top');
      slot.flipBot.classList.add('anim-bot');

      // tick per step
      playTick(0.08 + Math.random() * 0.06, 1700 + Math.random() * 300, 0.03);

      // after animation, commit the glyph
      setTimeout(() => {
        slot.topStatic.textContent = next;
        slot.botStatic.textContent = next;
        slot.current = next;
        cur = next;
        if (cur !== tgt) {
          setTimeout(step, STEP_MS + Math.random()*10);
        } else {
          resolve();
        }
      }, 360); // slightly longer than CSS duration to be safe
    }

    setTimeout(step, delay);
  });
}

/* batch update: flips only differing slots, staggered cascade */
async function updateRow(rowIndex, message) {
  const slots = boardSlots[rowIndex];
  const msg = (message || '').toString().toUpperCase().padEnd(COLS, ' ').slice(0, COLS);
  const tasks = [];
  for (let i = 0; i < COLS; i++) {
    const slot = slots[i];
    const tgt = msg[i] || ' ';
    if ((slot.current || ' ') !== tgt) {
      // left->right cascade: base delay + little jitter
      const delay = Math.floor(i * 20 + Math.random() * 40);
      tasks.push(scheduleFlip(slot, tgt, delay));
    }
  }
  if (tasks.length > 3) playRattle(0.95, 0.18);
  await Promise.all(tasks);
}

/* =============== BOARD UPDATE (fetching board.json) =============== */
async function fetchBoard() {
  meta.textContent = 'Updating…';
  try {
    const res = await fetch(BOARD_JSON + '?_=' + Date.now(), { cache: 'no-store' });
    if (!res.ok) throw new Error('Fetch failed: ' + res.status);
    const data = await res.json();
    const lines = (Array.isArray(data.lines) ? data.lines : data.rows || []).slice(0, ROWS);
    // ensure we have ROWS elements
    while (lines.length < ROWS) lines.push('');
    // perform row updates in parallel (but each row cascades left→right)
    const rowPromises = [];
    for (let r = 0; r < ROWS; r++) {
      rowPromises.push(updateRow(r, lines[r]));
    }
    await Promise.all(rowPromises);
    meta.textContent = 'Last update: ' + new Date().toLocaleTimeString();
  } catch (err) {
    console.error(err);
    meta.textContent = 'Load error — showing last data';
    // small audible error rattle
    playRattle(0.65, 0.14);
  }
}

/* =============== BOOT SEQUENCE =============== */
async function boot() {
  // random flicker for a few frames
  for (let k = 0; k < 8; k++) {
    const rndLines = Array.from({length: ROWS}, () =>
      Array.from({length: COLS}, () => GLYPH_ORDER[Math.floor(Math.random()*GLYPH_ORDER.length)]).join('')
    );
    for (let r = 0; r < ROWS; r++) {
      // fast replace to create noise
      const slots = boardSlots[r];
      for (let c = 0; c < COLS; c++) {
        const s = slots[c];
        s.topStatic.textContent = rndLines[r][c];
        s.botStatic.textContent = rndLines[r][c];
        s.current = rndLines[r][c];
      }
    }
    await new Promise(res => setTimeout(res, 80));
  }
  meta.textContent = AUDIO_ENABLED_MSG + ' — ready';
  // then immediate fetch
  await fetchBoard();
}

/* initial run */
boot().then(() => {
  setInterval(fetchBoard, POLL_MS);
});
</script>
</body>
</html>
