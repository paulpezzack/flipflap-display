<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Split-Flap Board — Balloon Reboot</title>
<style>
  :root {
    --bg: #050505;
    --panel: linear-gradient(180deg,#0a0a0a,#050505);
    --flap-bg: #0b0b0b;
    --flap-edge: #222;
    --text: #fff;
  }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: "Roboto Mono", monospace; }
  .wrap { min-height:100vh; display:flex; align-items:center; justify-content:center; padding:24px; box-sizing:border-box; }
  .board { background:var(--panel); padding:18px; border-radius:12px; box-shadow:0 18px 50px rgba(0,0,0,0.7); }
  .rows { display:flex; flex-direction:column; gap:10px; }
  .row { display:flex; gap:0.14em; justify-content:center; }
  .slot { width:calc(1.05ch + 8px); height:3.6rem; perspective:700px; position:relative; }
  .flap { width:100%; height:100%; border-radius:6px; background:var(--flap-bg); border:1px solid var(--flap-edge); }
  .half { position:absolute; left:0; right:0; height:50%; display:flex; align-items:center; justify-content:center; backface-visibility:hidden; }
  .half.top { top:0; background:linear-gradient(#111,#0b0b0b); }
  .half.bot { bottom:0; background:linear-gradient(#060606,#090909); }

  .balloon-screen {
    position:fixed;
    inset:0;
    display:flex;
    background:#000;
    align-items:center;
    justify-content:center;
    z-index:9999;
    opacity:0;
    pointer-events:none;
    transition:opacity 0.4s;
  }
  .balloon-screen.visible {
    opacity:1;
    pointer-events:auto;
  }
  .balloon-screen img {
    width:260px;
    height:auto;
    filter:drop-shadow(0 0 20px #ff5);
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="board" id="boardRoot">
    <div class="rows" id="rowsContainer"></div>
    <div class="meta" id="meta">Booting…</div>
  </div>
</div>

<div class="balloon-screen" id="balloonScreen">
  <img src="balloon.png" alt="Balloon" />
</div>

<script>
const BOARD_JSON = "board.json";
const ROWS = 5;
const COLS = 24;
const STEP_MS = 60;
const POLL_MS = 30000;
const GLYPH_ORDER = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-.,:/()'.split('');

const rowsContainer = document.getElementById("rowsContainer");
const meta = document.getElementById("meta");
const balloonScreen = document.getElementById("balloonScreen");
let pollTimer = null;
let boardSlots = [];

function buildBoard() {
  rowsContainer.innerHTML = "";
  boardSlots = [];
  for (let r = 0; r < ROWS; r++) {
    const rowEl = document.createElement("div");
    rowEl.className = "row";
    const slots = [];
    for (let c = 0; c < COLS; c++) {
      const slot = document.createElement("div");
      slot.className = "slot";
      slot.innerHTML = `
        <div class="flap">
          <div class="half top"><div class="char current-top"> </div></div>
          <div class="half bot"><div class="char current-bot"> </div></div>
        </div>`;
      slots.push({ el:slot, top:slot.querySelector('.current-top'), bot:slot.querySelector('.current-bot'), current:' '});
      rowEl.appendChild(slot);
    }
    boardSlots.push(slots);
    rowsContainer.appendChild(rowEl);
  }
}
buildBoard();

function glyphIndex(ch){let s=(ch||' ').toString().toUpperCase();let i=GLYPH_ORDER.indexOf(s);return i===-1?0:i;}
function nextGlyph(cur,target){let a=glyphIndex(cur),b=glyphIndex(target);if(a===b)return cur;return GLYPH_ORDER[(a+1)%GLYPH_ORDER.length];}

function scheduleFlip(slot,target){return new Promise(res=>{let cur=slot.current;let tgt=target;
  function step(){let next=nextGlyph(cur,tgt);
    slot.top.textContent = next;
    slot.bot.textContent = next;
    slot.current = next;
    if(next!==tgt) setTimeout(step, STEP_MS);
    else res();
  }
  step();
});}

async function updateRow(r,msg){msg = msg.padEnd(COLS,' ').slice(0,COLS);
  let tasks=[];
  for(let c=0;c<COLS;c++){
    let s = boardSlots[r][c];
    if(s.current!==msg[c]) tasks.push(scheduleFlip(s,msg[c]));
  }
  await Promise.all(tasks);
}

async function fetchBoard(){
  meta.textContent = "Updating…";
  const res = await fetch(BOARD_JSON+'?_='+(Date.now()));
  const data = await res.json();
  const lines = data.lines || data.rows || [];
  for(let r=0;r<ROWS;r++) await updateRow(r, lines[r]||"");
  meta.textContent = "Last update: "+new Date().toLocaleTimeString();
}

async function flicker(){
  // Use requestAnimationFrame-based flicker to avoid blocking
  let cycles = 8;
  function doCycle(resolve){
    if(cycles<=0){ resolve(); return; }
    cycles--;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        let s = boardSlots[r][c];
        let ch = GLYPH_ORDER[Math.floor(Math.random()*GLYPH_ORDER.length)];
        s.top.textContent = ch;
        s.bot.textContent = ch;
        s.current = ch;
      }
    }
    setTimeout(()=>{
      requestAnimationFrame(()=>doCycle(resolve));
    }, 40);
  }
  return new Promise(res=>doCycle(res));
}
    }
    await new Promise(r=>setTimeout(r,80));
  }
}

async function reboot(){
  // RESET BOARD
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let s = boardSlots[r][c];
      s.top.textContent = ' ';
      s.bot.textContent = ' ';
      s.current = ' ';
    }
  }

  // BALLOON DISPLAY
  balloonScreen.classList.add("visible");
  await new Promise(r=>setTimeout(r,2000));
  balloonScreen.classList.remove("visible");

  // FLICKER
  await flicker();

  // LOAD MESSAGE
  await fetchBoard();
}

async function startCycle(){
  await reboot();
  if(pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(()=>{
    reboot();
  }, POLL_MS);
}

startCycle();
</script>
</body>
</html>
