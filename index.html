<script>
/* ================= CONFIG ================= */
const BOARD_JSON = 'board.json';
const ROWS = 5;
const COLS = 24;
const POLL_MS = 30000;        // 30 seconds
const STEP_MS = 60;
const GLYPH_ORDER = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-.,:/()'.split('');
const AUDIO_ENABLED_MSG = 'Tap to enable sound';

/* prevent overlapping boots */
let bootRunning = false;

let pollTimer = null;

/* =============== AUDIO ENGINE =============== */
const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioContextCtor ? new AudioContextCtor() : null;

function playTick(volume = 0.25, freq = 1700, dur = 0.03) {
  if (!audioCtx) return;
  if (audioCtx.state !== "running") return;

  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.value = freq;
  g.gain.value = volume * 0.8;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

function playRattle(intensity = 0.8, duration = 0.12) {
  if (!audioCtx) return;
  if (audioCtx.state !== "running") return;

  const sr = audioCtx.sampleRate;
  const buffer = audioCtx.createBuffer(1, sr * duration, sr);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) {
    const t = i / data.length;
    data[i] = (Math.random() * 2 - 1) * (1 - t) * intensity;
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const gain = audioCtx.createGain();
  gain.gain.value = 0.6 * intensity;
  src.connect(gain); gain.connect(audioCtx.destination);
  src.start();
}

document.addEventListener('click', () => {
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }
}, { once: true });

/* =============== BUILD DOM ================= */
const rowsContainer = document.getElementById('rowsContainer');
const meta = document.getElementById('meta');
const boardSlots = [];

function buildBoard() {
  rowsContainer.innerHTML = '';
  boardSlots.length = 0;

  for (let r = 0; r < ROWS; r++) {
    const rowEl = document.createElement('div');
    rowEl.className = 'row';
    const slots = [];

    for (let c = 0; c < COLS; c++) {
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.innerHTML = `
        <div class="flap">
          <div class="half top"><div class="char current-top"> </div></div>
          <div class="half bot"><div class="char current-bot"> </div></div>
          <div class="flip-top"><div class="char next-top"> </div></div>
          <div class="flip-bot"><div class="char next-bot"> </div></div>
        </div>`;
      rowEl.appendChild(slot);

      const f = {
        el: slot,
        topStatic: slot.querySelector('.current-top'),
        botStatic: slot.querySelector('.current-bot'),
        flipTop: slot.querySelector('.flip-top'),
        flipTopChar: slot.querySelector('.flip-top .next-top'),
        flipBot: slot.querySelector('.flip-bot'),
        flipBotChar: slot.querySelector('.flip-bot .next-bot'),
        current: ' '
      };

      slots.push(f);
    }

    boardSlots.push(slots);
    rowsContainer.appendChild(rowEl);
  }
}
buildBoard();

/* =============== HELPERS ================= */
function glyphIndex(ch) {
  const s = (ch || ' ').toString().toUpperCase();
  const i = GLYPH_ORDER.indexOf(s);
  return i === -1 ? 0 : i;
}

function nextGlyph(cur, target) {
  const a = glyphIndex(cur);
  const b = glyphIndex(target);
  if (a === b) return cur;
  return GLYPH_ORDER[(a + 1) % GLYPH_ORDER.length];
}

/* =============== FLIP LOGIC ================= */
function scheduleFlip(slot, targetChar, delay = 0) {
  return new Promise(resolve => {
    let cur = slot.current;
    const tgt = targetChar.toUpperCase();

    if (cur === tgt) return resolve();

    function step() {
      const next = nextGlyph(cur, tgt);

      // prepare faces
      slot.flipTopChar.textContent = cur;
      slot.flipBotChar.textContent = next;

      // restart animations
      slot.flipTop.classList.remove('anim-top');
      slot.flipBot.classList.remove('anim-bot');
      void slot.flipTop.offsetWidth;
      void slot.flipBot.offsetWidth;
      slot.flipTop.classList.add('anim-top');
      slot.flipBot.classList.add('anim-bot');

      playTick();

      setTimeout(() => {
        slot.topStatic.textContent = next;
        slot.botStatic.textContent = next;
        slot.current = next;
        cur = next;

        if (cur !== tgt) {
          setTimeout(step, STEP_MS);
        } else {
          resolve();
        }
      }, 330);
    }

    setTimeout(step, delay);
  });
}

async function updateRow(r, message) {
  const slots = boardSlots[r];
  const msg = (message || '').padEnd(COLS, ' ').slice(0, COLS);

  const tasks = [];

  for (let i = 0; i < COLS; i++) {
    const slot = slots[i];
    const tgt = msg[i];
    if (slot.current !== tgt) {
      tasks.push(scheduleFlip(slot, tgt, i * 20));
    }
  }

  if (tasks.length > 3) playRattle();
  await Promise.all(tasks);
}

/* =============== FETCH DATA ================= */
async function fetchBoard() {
  meta.textContent = 'Updating…';

  try {
    const res = await fetch(BOARD_JSON + '?_t=' + Date.now(), { cache: 'no-store' });
    const data = await res.json();

    const lines = (data.lines || data.rows || []).slice(0, ROWS);
    while (lines.length < ROWS) lines.push('');

    await Promise.all(lines.map((line, i) => updateRow(i, line)));

    meta.textContent = "Last update: " + new Date().toLocaleTimeString();
  } catch {
    meta.textContent = "Load error — keeping last data";
    playRattle(0.5);
  }
}

/* =============== BOOT ================= */
async function boot() {
  // clear board first
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const s = boardSlots[r][c];
      s.topStatic.textContent = ' ';
      s.botStatic.textContent = ' ';
      s.current = ' ';
    }
  }

  // flicker
  for (let k = 0; k < 6; k++) {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const s = boardSlots[r][c];
        const rnd = GLYPH_ORDER[Math.floor(Math.random()*GLYPH_ORDER.length)];
        s.topStatic.textContent = rnd;
        s.botStatic.textContent = rnd;
        s.current = rnd;
      }
    }
    await new Promise(res => setTimeout(res, 70));
  }

  await fetchBoard();
}

/* =============== SAFE BOOT WRAPPER ================= */
async function queuedBoot() {
  if (bootRunning) return; // prevents overlap
  bootRunning = true;
  await boot();
  bootRunning = false;
}

/* INITIAL START */
queuedBoot();

/* RELOAD EVERY 30 SECONDS */
pollTimer = setInterval(queuedBoot, POLL_MS);

</script>
