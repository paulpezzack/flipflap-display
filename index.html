<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Split-flap Departure Board — Live</title>
<style>
  :root{
    --bg:#050505;
    --flap-bg:#0b0b0b;
    --flap-edge:#222;
    --flap-text:#fff;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family: 'Roboto Mono', ui-monospace, SFMono-Regular, Menlo, monospace;color:var(--flap-text);}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px;box-sizing:border-box}
  .board{
    background:linear-gradient(180deg,#0a0a0a 0%, #050505 100%);
    padding:16px;border-radius:10px;box-shadow:0 10px 40px rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.03);
    display:inline-block;
    max-width:calc(36ch + 120px);
  }
  .row { display:flex; gap:0.14em; margin:8px 0; align-items:center; justify-content:center; }
  .slot {
    width:calc(1.04ch + 6px);
    height:3.6rem;
    position:relative;
    perspective:700px;
    display:inline-block;
  }

  .flap {
    width:100%;height:100%;position:relative;box-sizing:border-box;border-radius:4px;
    background:var(--flap-bg);box-shadow: inset 0 -3px 6px rgba(0,0,0,.6);border:1px solid var(--flap-edge);overflow:visible;
  }

  .half {
    position:absolute;left:0;right:0;height:50%;overflow:hidden;display:flex;align-items:center;justify-content:center;
    backface-visibility:hidden;
  }
  .half.top { top:0; border-bottom:1px solid rgba(255,255,255,0.03); border-top-left-radius:4px;border-top-right-radius:4px; background: linear-gradient(#0f0f0f,#0b0b0b); }
  .half.bot { bottom:0; border-top:1px solid rgba(0,0,0,0.5); border-bottom-left-radius:4px;border-bottom-right-radius:4px; background: linear-gradient(#060606,#090909); }

  .flip-top, .flip-bot {
    position:absolute;left:0;right:0;height:50%;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    pointer-events:none;
  }
  .flip-bot { transform-origin:top center; bottom:0; top:auto; }

  .char {
    font-size:1.75rem; line-height:1; letter-spacing:0.02em; user-select:none; color:var(--flap-text);
  }

  .anim-top { animation: topFlip 220ms forwards; }
  .anim-bot { animation: botFlip 220ms 160ms forwards; }

  @keyframes topFlip {
    0%   { transform: rotateX(0deg); }
    60%  { transform: rotateX(-100deg); }
    100% { transform: rotateX(-180deg); visibility:hidden; }
  }
  @keyframes botFlip {
    0%   { transform: rotateX(90deg); visibility:hidden; }
    40%  { transform: rotateX(10deg); visibility:visible; }
    100% { transform: rotateX(0deg); visibility:visible; }
  }

  .meta { color: #9aa0a6; font-size:0.82rem; text-align:center; margin-top:8px; }
  @media (max-width:700px){
    .slot{ width:calc(1.0ch + 2px); height:3.0rem }
    .char { font-size:1.2rem }
    .board { padding:10px }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="board" id="boardRoot" role="region" aria-label="Departure board"></div>
  </div>

<script>
/* ============= CONFIG ============= */
// Published sheet URL (you provided this). We use the gviz endpoint for JSON-style responses.
const BASE_PUBURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSZC7o-uCL_EPgbwLY9Vrf4E0nN2XkeOtXBxUtqrm3y77GOV1T5NtX5skMusVZBbmuU5ikPsQssqZca';
const SHEET_URL = BASE_PUBURL + '/gviz/tq?tq=select%20*';

// Display config
const ROWS = 5;           // shows first 5 rows from sheet (you chose 5)
const COLS = 36;          // characters per row
const REFRESH_MS = 10000; // refresh every 10s
const STEP_MS = 60;       // ms between glyph steps (controls speed)
const GLYPHS = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-.,:;/\\'.split('');

let rows = []; // will hold slot refs

/* ============= AUDIO (synth rattle) ============= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function ensureAudio() {
  if (audioCtx.state === 'suspended') return audioCtx.resume();
  return Promise.resolve();
}
function playRattle(intensity = 0.6, duration = 0.12) {
  // safe to call; resumes audio context if needed
  ensureAudio().then(() => {
    const sr = audioCtx.sampleRate;
    const buf = audioCtx.createBuffer(1, Math.floor(sr * duration), sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) {
      const t = i / d.length;
      d[i] = (Math.random() * 2 - 1) * (1 - t) * intensity * (Math.random() > 0.5 ? 1 : 0.6);
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const f = audioCtx.createBiquadFilter();
    f.type = 'bandpass';
    f.frequency.value = 2000;
    f.Q.value = 0.7;
    const g = audioCtx.createGain();
    g.gain.value = 0.9;
    src.connect(f); f.connect(g); g.connect(audioCtx.destination);
    src.start();
    src.stop(audioCtx.currentTime + duration);
  }).catch(()=>{/* ignore resume failures */});
}

/* ============= UTIL ============= */
function idxOfGlyph(ch) {
  const u = (ch || ' ').toString().toUpperCase();
  const i = GLYPHS.indexOf(u);
  return i === -1 ? 0 : i;
}
function nextGlyph(cur, target) {
  const a = idxOfGlyph(cur);
  const b = idxOfGlyph(target);
  if (a === b) return cur;
  let i = (a + 1) % GLYPHS.length;
  return GLYPHS[i];
}

/* ============= BUILD BOARD DOM ============= */
const root = document.getElementById('boardRoot');
function buildBoard() {
  root.innerHTML = '';
  rows = [];
  for (let r = 0; r < ROWS; r++) {
    const rowEl = document.createElement('div');
    rowEl.className = 'row';
    const slotRefs = [];
    for (let c = 0; c < COLS; c++) {
      const slot = document.createElement('div');
      slot.className = 'slot';

      const flap = document.createElement('div');
      flap.className = 'flap';

      const topStatic = document.createElement('div');
      topStatic.className = 'half top';
      const topStaticChar = document.createElement('div');
      topStaticChar.className = 'char current-top';
      topStaticChar.textContent = ' ';
      topStatic.appendChild(topStaticChar);

      const botStatic = document.createElement('div');
      botStatic.className = 'half bot';
      const botStaticChar = document.createElement('div');
      botStaticChar.className = 'char current-bot';
      botStaticChar.textContent = ' ';
      botStatic.appendChild(botStaticChar);

      const flipTop = document.createElement('div');
      flipTop.className = 'flip-top';
      const flipTopChar = document.createElement('div');
      flipTopChar.className = 'char next-top';
      flipTopChar.textContent = ' ';
      flipTop.appendChild(flipTopChar);

      const flipBot = document.createElement('div');
      flipBot.className = 'flip-bot';
      const flipBotChar = document.createElement('div');
      flipBotChar.className = 'char next-bot';
      flipBotChar.textContent = ' ';
      flipBot.appendChild(flipBotChar);

      flap.appendChild(topStatic);
      flap.appendChild(botStatic);
      flap.appendChild(flipTop);
      flap.appendChild(flipBot);
      slot.appendChild(flap);
      rowEl.appendChild(slot);

      slotRefs.push({
        el: slot,
        topStaticChar,
        botStaticChar,
        flipTop, flipTopChar,
        flipBot, flipBotChar,
        current: ' '
      });
    }
    root.appendChild(rowEl);
    rows.push(slotRefs);
  }
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.id = 'boardMeta';
  meta.textContent = 'Waiting for data… (click page to enable sound)';
  root.appendChild(meta);
}
buildBoard();

/* ============= FLIP LOGIC ============= */
function scheduleFlip(slot, targetChar, delay = 0) {
  return new Promise(resolve => {
    let cur = slot.current || ' ';
    const tgt = (targetChar || ' ').toString().toUpperCase();
    if (cur === tgt) { resolve(); return; }

    function stepOnce() {
      const next = nextGlyph(cur, tgt);
      slot.flipTopChar.textContent = cur;
      slot.flipBotChar.textContent = next;

      slot.flipTop.classList.remove('anim-top');
      slot.flipBot.classList.remove('anim-bot');
      // force reflow to retrigger
      void slot.flipTop.offsetWidth;
      void slot.flipBot.offsetWidth;
      slot.flipTop.classList.add('anim-top');
      slot.flipBot.classList.add('anim-bot');

      // sound for this single-step
      playRattle(0.28, 0.05);

      setTimeout(() => {
        // update static faces to next
        slot.topStaticChar.textContent = next;
        slot.botStaticChar.textContent = next;
        slot.current = next;
        cur = next;
        if (cur !== tgt) {
          setTimeout(stepOnce, STEP_MS);
        } else {
          resolve();
        }
      }, 360); // slightly longer than CSS to be safe
    }

    setTimeout(stepOnce, delay);
  });
}

async function updateRow(rowIndex, message) {
  const slots = rows[rowIndex];
  const msg = (message || '').toString().toUpperCase().padEnd(COLS, ' ').slice(0, COLS);
  const flips = [];
  for (let i = 0; i < COLS; i++) {
    const slot = slots[i];
    const tgt = msg[i] || ' ';
    if ((slot.current || ' ') !== tgt) {
      // small random stagger per character for realism
      const delay = Math.floor(i * 20 + Math.random() * 30);
      flips.push(scheduleFlip(slot, tgt, delay));
    }
  }
  if (flips.length > 3) {
    // a fuller cascade gets an extra rattle
    playRattle(0.9, 0.18);
  }
  await Promise.all(flips);
}

/* ============= SHEET FETCH ============= */
async function fetchSheetAndApply() {
  const meta = document.getElementById('boardMeta');
  try {
    meta.textContent = 'Loading…';
    const res = await fetch(SHEET_URL + '&_=' + Date.now(), { cache: 'no-store' });
    const text = await res.text();
    const match = text.match(/google\\.visualization\\.Query\\.setResponse\\((.*)\\);/s);
    if (!match) throw new Error('Unexpected sheet response format');
    const data = JSON.parse(match[1]);
    const sheetRows = (data.table?.rows || []);
    // Populate the first ROWS entries (if sheet has fewer lines, show blanks)
    for (let r = 0; r < ROWS; r++) {
      const cellVal = sheetRows[r]?.c?.[0]?.v ?? '';
      // update each row separately (non-blocking)
      updateRow(r, cellVal).catch(e => console.error('row update error', e));
    }
    const ts = new Date();
    meta.textContent = `Last: ${ts.toLocaleString()} — ${Math.min(sheetRows.length, ROWS)} lines loaded`;
  } catch (err) {
    console.error('Sheet fetch error', err);
    const meta = document.getElementById('boardMeta');
    meta.textContent = 'Error loading sheet — check publish settings';
  }
}

/* ============= STARTUPS & POLLING ============= */
// enable audio on first user interaction (some browsers block autoplay)
document.addEventListener('click', () => {
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{/*ignore*/});
  }
}, { once: true });

// initial load
fetchSheetAndApply().catch(e => console.error(e));
// poll
setInterval(fetchSheetAndApply, REFRESH_MS);

</script>
</body>
</html>
